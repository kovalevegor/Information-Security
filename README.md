# Потоковые шифры

*Полный листинг кода см. в файле* `RC4.py`

### Алгоритм согласования ключей (KSA):

**Инициализация:**

+ `key`: Секретный ключ ("*KAPERNIK*" в этом примере).
+ `key_length`: Длина ключа (8 в данном случае).
+ `S`: Список целых чисел от 0 до 255, представляющий состояние.
+ `j`: Индексная переменная, инициализированная как 0.

**Циклирование по S:**

+ Перебираем каждый элемент `i` в `S` (256 раз).
+ Для числовых символов:
  + Если символ в индексе `i % key_length` в `key` является числовым (не в этом примере):
    + Добавляем значение `S[i]`, соответствующий символ `key` как целое число (не применимо здесь) и `j`, все по модулю 256 (чтобы сохранить результат в пределах 0-255).
    + Меняем местами значения `S[i]` и `S[j]` в состоянии.
+  Для нечисловых символов:
  + В этом примере `KAPERNIK` содержит нечисловые символы, поэтому эта часть пропускается.

**Возврат S:**

+ После итерации по всем элементам `S` возвращается измененное состояние.

### Алгоритм псевдослучайной генерации (PRGA):

**Инициализация:**

+ `S`: Измененное состояние из `KSA`.
+ `n`: Длина желаемого keystream (та же, что и у открытого текста).
+ `i`, `j`: Индексные переменные, инициализированные как 0.
+ `key`: Пустой список для хранения генерируемого `keystream`.

**Циклирование для генерации keystream:**

+ Повторить `n` раз:
  + Обновить `i` и `j`, увеличивая их на 1 по модулю 256 (с переходом).
  + Поменять местами значения `S[i]` и `S[j]` в состоянии.
  + Сгенерировать псевдослучайный байт `k`, взяв значение в индексе `(S[i] + S[j]) % 256` в состоянии.
  + Добавить `k` в список `key`.

**Возврат keystream:**

+ После генерации `n` байтов возвращается список `key`, содержащий `keystream`.

### Шифрование:

Подготовка открытого текста:

+ `plaintext`: Сообщение, которое нужно зашифровать ("*Mission Impossible*").
+ Преобразовать каждый символ в открытом тексте в его соответствующий код `ASCII` и сохранить их в массиве `NumPy`.

**Генерация keystream:**

+ Вызвать `PRGA` с измененным состоянием `S` и длиной открытого текста (`n`), чтобы получить `keystream`.

**Операция XOR:**

+ Выполнить побитовое $\oplus$ между массивом открытого текста и массивом `keystream`.
+ Результат - это шифротекст, который также преобразуется в массив `NumPy` байтов.

**Печать результатов:**

+ Шифротекст печатается в шестнадцатеричном формате и в виде символов.

### Пример:

1. **KSA:** Детальное выполнение `KSA` с "*KAPERNIK*" в качестве ключа выходит за рамки этого объяснения из-за его сложности и нечисловых символов.

2. **PRGA:** Предположим, что после `KSA` измененное состояние `S` генерирует `keystream` (пример байтов):

```python
keystream = [17, 23, 41, 12, ...]
```

3. Шифрование:

+ **Открытый текст:** "*Mission Impossible*" (ASCII коды: [77, 105, 115, 115, 105, 111, 110, 32, 73, 109, 112, 111, 115, 115, 105, 99, 101])
+ `XOR` с `keystream`:

```python
cipher = plaintext ^ keystream
cipher = [60, 82, 74, 99, ...]
```

4. Печать результатов:
5. 
```python
[254   0   3   7  12  14  23  31  40  40  56  68  63  86 101 117 134 152]
[254   0   3   7  12  14  23  31  40  40  56  68  63  86 101 117 134 152]
b36970746561793f6145482b4c250c17eafd
['³', 'i', 'p', 't', 'e', 'a', 'y', '?', 'a', 'E', 'H', '+', 'L', '%', '\x0c', '\x17', 'ê', 'ý']
```
